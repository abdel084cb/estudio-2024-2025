![[Pasted image 20250110225333.png]]
### Ejercicio 1
##### a) Para etiquetar SOLO usa DATE si no te especifican nada mas. Igualmente se le puede hablar sobre orden total o parcial teniendo las etiquetas de solo DATE, solo habría que añadir el PID a la derecha, es algo irrelevante. Pero que en una pregunta de teoría sobre los ordenes se lo puedes indicar.
![[Pasted image 20250110230258.png]]
##### b)
![[Pasted image 20250110231802.png]]

##### c)
Falso, los relojes vectoriales determinan orden parcial. La ventaja que tienen sobre los escalares (los cuales además pueden determinar orden total mediante (date, PID)), es que los vectoriales pueden determinar si los eventos están causalmente relacionados, es decir. Distinguen entre eventos concurrentes. Por ejemplo (1,0,0,0) y (0,1,0,0) no son comparables al no tener una relación de causalidad.

![[Pasted image 20250111002114.png]]
![[Pasted image 20250111002133.png]]
![[Pasted image 20250111002202.png]]
![[Pasted image 20250111002217.png]]

### Ejercicio 2
##### a)
`when sending a REQUEST (acquire_mutex) do`
	`lrdi <- clocki + 1`
	`send(REQUEST(lrdi,i))
`when receiving REQUEST(lrdi,i)`
	`clockj <- max(clockj,lrdi)`

Esto sin tener en cuenta el aumento de reloj en eventos internos. Es decir solo utilizamos el reloj para los mutex. Y teniendo en cuenta que clock = Highest_Sequence_Number, y lrd = Our_Sequence_Number.
##### b)
En los relojes lógicos de Lamport, el enfoque principal es mantener un orden causal entre eventos en un sistema distribuido. Esto se logra mediante un reloj lógico local que se incrementa en eventos internos y se sincroniza con los mensajes enviados y recibidos. Este mecanismo no está diseñado para gestionar acceso a secciones críticas.

Por otro lado, en el algoritmo de Ricart-Agrawala, los relojes tienen una función específica para coordinar el acceso a una sección crítica. Se utilizan dos relojes:
1. **`Our Sequence`**: Representa el número de secuencia generado al solicitar acceso a la sección crítica.
2. **`Highest Sequence`**: Almacena el valor más alto de secuencia observado en cualquier mensaje recibido.
Estas diferencias se deben a los objetivos de cada sistema:
- Los relojes de Lamport buscan establecer un orden causal entre eventos en general.
- Los relojes en Ricart-Agrawala están diseñados específicamente para garantizar exclusión mutua en la sección crítica, asegurando que las solicitudes se procesen en el orden correcto y gestionando las prioridades de acceso.

Además, en Ricart-Agrawala no se incrementa el reloj en eventos internos porque no son relevantes para la gestión de la sección crítica, mientras que en Lamport sí se considera esencial para mantener el orden causal entre todos los eventos del sistema.

En Ricart-Agrawala, el reloj solo se incrementa cuando un nodo **envía una solicitud** de acceso a la sección crítica. Este incremento asegura que las solicitudes tengan un ordenado, ya que en caso de que fuesen iguales, se desempata con el PID del proceso.

##### c)
P1,P2,P3 y P4
estado inicial:
	P1 en SC
	P2,P3 y P4 fuera de SC y no han solicitado mutex
###### c1)
1. P3 solicita mutex
2. P2 solicita mutex
3. P4 solicita mutex

Suponiendo que llegan en ese orden y que ha dado tiempo que los relojes se sincronicen correctamente:

**P3 solicita mutex**
Estado P1:
"dentro de SC"
`Reply_Deferred[FALSE,FALSE,TRUE,FALSE]`
Estado P2:
"en otras tareas"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`
Estado P3:
"solicitando mutex"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`
Estado P4:
"en otras tareas"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`

**P2 solicita mutex**
Estado P1:
"dentro de SC"
`Reply_Deferred[FALSE,TRUE,TRUE,FALSE]`
Estado P2:
"solicitando mutex"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`
Estado P3:
"solicitando mutex"
`Reply_Deferred[FALSE,TRUE,FALSE,FALSE]`
Estado P4:
"en otras tareas"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`

**P4 solicita mutex**
Estado P1:
"dentro de SC"
`Reply_Deferred[FALSE,TRUE,TRUE,TRUE]`
Estado P2:
"solicitando mutex"
`Reply_Deferred[FALSE,FALSE,FALSE,TRUE]`
Estado P3:
"solicitando mutex"
`Reply_Deferred[FALSE,TRUE,FALSE,TRUE]`
Estado P4:
"solicitando mutex"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`

Si fuese todo a la vez habría que desempatar por PID

###### c2)
**P4 solicita mutex**
Estado P1:
"en otras tareas"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`
Estado P2:
"solicitando mutex"
`Reply_Deferred[FALSE,FALSE,FALSE,TRUE]`
Estado P3:
"dentro de SC"
`Reply_Deferred[FALSE,TRUE,FALSE,TRUE]`
Estado P4:
"solicitando mutex"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`

![[Pasted image 20250111164457.png]]
### Ejercicio 3
##### a)
Sirve para seleccionar un proceso que actúe como coordinador o líder en un sistema distribuido. El líder será responsable de gestionar tareas críticas, como la asignación de recursos, la sincronización o la toma de decisiones globales. Además, este mecanismo aumenta la tolerancia a fallos ya que permite al sistema recuperarse automáticamente cuando el líder falla.
##### b)

**RTT** significa **Round-Trip Time** o tiempo de ida y vuelta. Es el tiempo que tarda un mensaje en viajar desde un emisor hasta un receptor y que la respuesta de ese receptor vuelva al emisor.

- **Mejor caso (1 RTT, N-1 mensajes)**:
    - Ocurre cuando el proceso con **mayor PID detecta directamente la falla** del líder.
    - Este proceso se autoproclama líder y envía un único mensaje de **Coordinador** a los demás procesos.
- **Peor caso (N-1 RTTs, O(N²) mensajes)**:
    - Sucede si el proceso con **menor PID inicia la elección**.
    - Este proceso debe enviar mensajes de **Elección** a procesos con mayor PID, quienes a su vez continúan propagando la elección hasta llegar al proceso con el mayor PID. Luego, este último envía mensajes de **Coordinador** a todos los demás

![[Pasted image 20250111175119.png]]
##### c)
- **Timeout para detectar la falla del líder**:
    - Cada proceso monitorea al líder actual enviándole mensajes periódicos de "latido" (heartbeat) y espera su respuesta.
    - Si el proceso no recibe respuesta dentro de un tiempo definido, el timeout expira y el proceso asume que el líder ha fallado, iniciando una elección.
- **Timeout para esperar respuestas durante la elección**:
    - Cuando un proceso inicia una elección, envía mensajes de Elección a los procesos con mayor PID y espera respuestas (mensajes de Respuesta o Coordinador).
    - Si no recibe ninguna respuesta dentro del tiempo definido, el proceso asume que los procesos con mayor PID han fallado y se declara líder enviando un mensaje de Coordinador a todos los procesos vivos.
- Se ajustan con `2*RTT + Tprocesado`

![[Pasted image 20250111175250.png]]

![[Pasted image 20250110225333.png]]
### Ejercicio 1
##### a) Para etiquetar SOLO usa DATE si no te especifican nada mas. Igualmente se le puede hablar sobre orden total o parcial teniendo las etiquetas de solo DATE, solo habría que añadir el PID a la derecha, es algo irrelevante. Pero que en una pregunta de teoría sobre los ordenes se lo puedes indicar.
![[Pasted image 20250110230258.png]]
##### b)
![[Pasted image 20250110231802.png]]

##### c)
Falso, los relojes vectoriales determinan orden parcial. La ventaja que tienen sobre los escalares (los cuales además pueden determinar orden total mediante (date, PID)), es que los vectoriales pueden determinar si los eventos están causalmente relacionados, es decir. Distinguen entre eventos concurrentes. Por ejemplo (1,0,0,0) y (0,1,0,0) no son comparables al no tener una relación de causalidad.

![[Pasted image 20250111002114.png]]
![[Pasted image 20250111002133.png]]
![[Pasted image 20250111002202.png]]
![[Pasted image 20250111002217.png]]

### Ejercicio 2
##### a)
`when sending a REQUEST (acquire_mutex) do`
	`lrdi <- clocki + 1`
	`send(REQUEST(lrdi,i))
`when receiving REQUEST(lrdi,i)`
	`clockj <- max(clockj,lrdi)`

Esto sin tener en cuenta el aumento de reloj en eventos internos. Es decir solo utilizamos el reloj para los mutex. Y teniendo en cuenta que clock = Highest_Sequence_Number, y lrd = Our_Sequence_Number.
##### b)
En los relojes lógicos de Lamport, el enfoque principal es mantener un orden causal entre eventos en un sistema distribuido. Esto se logra mediante un reloj lógico local que se incrementa en eventos internos y se sincroniza con los mensajes enviados y recibidos. Este mecanismo no está diseñado para gestionar acceso a secciones críticas.

Por otro lado, en el algoritmo de Ricart-Agrawala, los relojes tienen una función específica para coordinar el acceso a una sección crítica. Se utilizan dos relojes:
1. **`Our Sequence`**: Representa el número de secuencia generado al solicitar acceso a la sección crítica.
2. **`Highest Sequence`**: Almacena el valor más alto de secuencia observado en cualquier mensaje recibido.
Estas diferencias se deben a los objetivos de cada sistema:
- Los relojes de Lamport buscan establecer un orden causal entre eventos en general.
- Los relojes en Ricart-Agrawala están diseñados específicamente para garantizar exclusión mutua en la sección crítica, asegurando que las solicitudes se procesen en el orden correcto y gestionando las prioridades de acceso.

Además, en Ricart-Agrawala no se incrementa el reloj en eventos internos porque no son relevantes para la gestión de la sección crítica, mientras que en Lamport sí se considera esencial para mantener el orden causal entre todos los eventos del sistema.

En Ricart-Agrawala, el reloj solo se incrementa cuando un nodo **envía una solicitud** de acceso a la sección crítica. Este incremento asegura que las solicitudes tengan un ordenado, ya que en caso de que fuesen iguales, se desempata con el PID del proceso.

##### c)
P1,P2,P3 y P4
estado inicial:
	P1 en SC
	P2,P3 y P4 fuera de SC y no han solicitado mutex
###### c1)
1. P3 solicita mutex
2. P2 solicita mutex
3. P4 solicita mutex

Suponiendo que llegan en ese orden y que ha dado tiempo que los relojes se sincronicen correctamente:

**P3 solicita mutex**
Estado P1:
"dentro de SC"
`Reply_Deferred[FALSE,FALSE,TRUE,FALSE]`
Estado P2:
"en otras tareas"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`
Estado P3:
"solicitando mutex"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`
Estado P4:
"en otras tareas"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`

**P2 solicita mutex**
Estado P1:
"dentro de SC"
`Reply_Deferred[FALSE,TRUE,TRUE,FALSE]`
Estado P2:
"solicitando mutex"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`
Estado P3:
"solicitando mutex"
`Reply_Deferred[FALSE,TRUE,FALSE,FALSE]`
Estado P4:
"en otras tareas"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`

**P4 solicita mutex**
Estado P1:
"dentro de SC"
`Reply_Deferred[FALSE,TRUE,TRUE,TRUE]`
Estado P2:
"solicitando mutex"
`Reply_Deferred[FALSE,FALSE,FALSE,TRUE]`
Estado P3:
"solicitando mutex"
`Reply_Deferred[FALSE,TRUE,FALSE,TRUE]`
Estado P4:
"solicitando mutex"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`

Si fuese todo a la vez habría que desempatar por PID

###### c2)
**P4 solicita mutex**
Estado P1:
"en otras tareas"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`
Estado P2:
"solicitando mutex"
`Reply_Deferred[FALSE,FALSE,FALSE,TRUE]`
Estado P3:
"dentro de SC"
`Reply_Deferred[FALSE,TRUE,FALSE,TRUE]`
Estado P4:
"solicitando mutex"
`Reply_Deferred[FALSE,FALSE,FALSE,FALSE]`